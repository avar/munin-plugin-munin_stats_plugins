#!/usr/bin/env perl
use 5.010;
use strict;
use warnings;
use autodie;
use Munin::Plugin;
use File::Temp qw(tempdir tempfile);
use Time::HiRes qw(gettimeofday tv_interval);
use File::Spec::Functions qw(catfile);
use File::Basename qw(basename);

my $statedir  = $ENV{MUNIN_PLUGSTATE};
my $statefile = $0; $statefile =~ s[^.*/][];
my $cache = catfile($statedir, $statefile . '-cache');
my $cache_tmp = "$cache.tmp";

my @plugins = parse_plugin_time($cache);

given ($ARGV[0]) {
    when ("config") {
        print <<END;
graph_title Munin plugin processing time
graph_scale yes
graph_vlabel seconds
graph_category munin
graph_info Shows the processing time of munin plugins in seconds
END
        for my $plugin (@plugins) {
            my ($time, $name) = @$plugin;
            my $fieldname = clean_fieldname($name);
            print <<END;
$fieldname.label $name
$fieldname.info The processing time of $name
$fieldname.draw AREASTACK
END
        }
    }
    when ("reload") {
        my @plugins = map { basename $_ } grep { -x } glob "/etc/munin/plugins/*";

        # Run all the plugins
        my %time;
        for my $plugin (@plugins) {
            my $t0 = [gettimeofday];

            open my $proc, "munin-run $plugin |";
            1 while <$proc>;
            close $proc;

            my $t1 = [gettimeofday];
            my $elapsed = tv_interval($t0, $t1);
            $time{$plugin} = sprintf "%0.2f", $elapsed;
        }

        # Write out the runtimes to a tempfile
        open my $fh, ">", $cache_tmp;
        while (my ($p, $t) = each %time) {
            say $fh "$t $p";
        }
        close $fh;

        # Rename the temp to the real thing. If we wrote it to begin
        # with we might have a race condition.
        rename $cache_tmp, $cache;
    }
    default {
        for my $plugin (@plugins) {
            my ($time, $name) = @$plugin;
            my $fieldname = clean_fieldname($name);
            print <<END;
$fieldname.value $time
END
        }
    }
}

sub parse_plugin_time
{
    my ($file) = @_;

    my $cont = do {
        local (@ARGV, $/) = $file;
        scalar <>;
    };

    my @plugins;
    while ($cont =~ /^ (?<time>[\d.]+) \s+ (?<plugin>.*) $/mgx) {
        push @plugins => [ $+{time} => $+{plugin} ];
    }

    # Sort by size
    @plugins = sort { $b->[0] <=> $a->[0] } @plugins;

    @plugins;
}
